---
publishDate: 2023-01-12T00:00:00Z
title: O que √© o terminal?
description: Desmistificando a tela preta
excerpt: Desmistificando a tela preta.
image: ~/assets/images/terminal.png
category: Articles
tags:
  - linux
  - terminal
  - command line
  - guide
canonical: https://gabo.link/o-que-e-o-terminal
---

import Slider from '~/components/blog/content/Slider.astro';
import Image from '~/components/blog/content/Image.astro';
import Card from '~/components/blog/content/Card.astro';

export const components = { img: Image };

Voc√™ j√° deve ter visto aquelas telas pretas, com linhas pequenas pipocando sem parar. Possivelmente em um filme, onde h√° um super hacker escrevendo dezenas de letras por segundo com o objetivo de quebrar todas as senhas e acessar um sistema secreto do pent√°gono. Essa janela preta √© um **terminal**.

A ideia desse texto √© desmistificar e explicar, em uma introdu√ß√£o geral, **tudo que voc√™ precisa saber para conhecer o `terminal`**, al√©m de mostrar o quanto ele pode ser divertido e √∫til.

# O que √© o terminal

## O hardware (o terminal burro)

Antes de ser mais conhecido como um programa, o terminal era um equipamento. Seu objetivo era o de **interagir com um computador por meio de texto**. Bem por isso, este √© sempre constituindo por um **teclado** para essa interface.

Mais especificamente, neste texto tudo se refere ao `v√≠deo terminal`, que **possui uma tela al√©m do teclado**, em contraste com terminais mais antigos, que **interfaciavam com o computador por impress√£o do texto** (semelhante ao fax). Um exemplo de video terminal √© o [VT100](https://pt.wikipedia.org/wiki/VT100).

![TI Silent 700 e VT100](/assets/images/posts/terminals.png)

E se logo de cara voc√™ est√° com medo, ou acha que deve ser muito dif√≠cil mexer em um terminal, quero que voc√™ me diga qu√£o dificil √© mexer nesse cara:

![Tela de chat](/assets/images/posts/chat.jpeg)

√â isso mesmo, um chat. Voc√™ sabe usar ele? Ent√£o voc√™ j√° tem metade do que precisa, acredite. De forma bem simples, o terminal √© um chat... com o seu computador! Nele voc√™ escrever√° algo para o computador, e ele vai lhe responder. **As mensagens que mandamos para o computador ser√£o sempre `comandos` para ele executar.**

E antigamente isso fazia mais sentido ainda. Visto que os computadores eram caros (e enormes), a melhor solu√ß√£o era ter v√°rios equipamentos menores que s√≥ pedem coisas para o √∫nico computador do local, como em universidades e bibliotecas. Esses equipamentos eram literalmente os terminais, tamb√©m chamados de **terminais burros**. Burro porque fazer algo sozinho ele n√£o fazia. N√£o possu√≠a mem√≥ria, nem processador dedicado. Ele s√≥ pedia para o servidor, e o servidor devolvia na tela o que lhe foi pedido.

## O software (o emulador de terminal)

Ter um computador em casa descarta a necessidade de ter um equipamento a mais pra falar com ele, mas falar por texto n√£o deixou de ser √∫til. Ainda se usa muito o terminal, por√©m agora ele √© um programa, tamb√©m conhecido como `emulador de terminal`. Agora sim, se tornando aquela janelinha preta, ele deixa de ser aquele monitor de tubo com comunica√ß√£o serial.

![O terminal como hardware e atualmente como software](/assets/images/posts/terminal-interface.png)

**O terminal agora vive dentro do pr√≥prio computador, se tornando apenas uma abstra√ß√£o digital mantida unicamente pela conveni√™ncia de comunica√ß√£o dos humanos para com as m√°quinas.**

E por meio de uma das interfaces mais antigas de computador, que ainda hoje vemos uma infinidade de usos e aplica√ß√µes para o ambiente de desenvolvimento e cotidiano no computador.

## O que o terminal tem

Diga oi para o meu terminal. Nesse texto mostrarei um terminal num sistema com Linux. Ele √© muito parecido com o Mac. Para o Windows os conceitos abordados aqui tamb√©m valem, por√©m h√° mudan√ßas para os nomes dos comandos mais comuns.

![Tela de um emulador de terminal](/assets/images/posts/emulator.png)

O terminal √© bem vazio de cara, porque ele √© s√≥ um monitor. Ele s√≥ mostra um programa al√≠ no topo. O `shell`!

**O shell √© o interpetador de comandos do terminal**, eu vou digitar nosso primeiro comando. O `ls`.

```bash
gabo@book:~/$ ls
```

Ele serve para `listar os arquivos` e subpastas presentes na pasta que voc√™ se encontra.

![Anatomia do Shell](/assets/images/posts/shell.png)

Em toda tela de terminal voc√™ vai se deparar com duas coisas:

- O `prompt`: Indica onde voc√™ come√ßa o seu comando, sua "mensagem". Nele costuma conter algumas informa√ß√µes √∫teis como **o diret√≥rio (pasta) que voc√™ est√°** ou **usu√°rio que voc√™s est√° logado**, al√©m de v√°rias outras coisas que voc√™ mesmo pode adicionar.

- A `linha de comando`: Espa√ßo onde se escreve o comando em si.

O `$` √© um indicador que tudo que vem depois dele deve ser interpretado como um comando. Quando voc√™ est√° logado como root, o s√≠mbolo muda para um `#`. Em sistemas baseados no DOS, como o windows, esse s√≠mbolo pode ser um `>`

Por sinal, tem v√°rias op√ß√µes de shell. O shell que eu mostrei √© o mais comum, o `bash`, mas no dia a dia eu uso o `zsh`, bem famoso pelas suas customiza√ß√µes.

![Exemplo de prompt do bash e zsh](/assets/images/posts/shell2.png)

Mais estiloso, n√©. E sim, eu curto roxo.

Quando um comando √© enviado, o sistema retornar√° a resposta logo embaixo, sendo poss√≠vel 3 op√ß√µes:

- **O que voc√™ pediu:** Quando o seu comando solicita alguma informa√ß√£o, essa informa√ß√£o aparecer√° logo abaixo da linha de comando;
- **Uma mensagem de erro:** Para quando o comando feito n√£o for executado corretamente. Seja por erro do programa ou por erro do usu√°rio ao digitar o que precisava;
- **Nada:** Nos casos que o computador executa o comando e nada precisa ser devolvido. Tudo ok üëå;

# Usando o terminal

Voltando ao comando de exemplo. O `ls`. Ele ser√° √∫til, pois no terminal voc√™ navega muito entre arquivos.

![O comando ls](/assets/images/posts/ls.png)

Notou o `~` logo no final do prompt? Ele simboliza a sua pasta `home`, a pasta inicial do seu usu√°rio, onde as suas coisas ficam no sistema. O comando `ls` me listou todas as pastas e arquivos da minha home.

Para irmos numa pasta especifica, o comando `cd` (_change directory_) servir√° para `mudar a pasta` que voc√™ se encontra. Vamos para a pasta study.

Note que ao mudarmos onde estamos, o prompt atualizar√° o caminho do diret√≥rio atual.

![Comando ls e cd](/assets/images/posts/ls-cd.png)

Para voltarmos para o diret√≥rio anterior, podemos escrever `cd ..`, onde `..` sempre se refere ao diret√≥rio pai do que voc√™ se encontra.

Os comandos por texto podem receber `par√¢metros`, mensagens a mais que informam formas espec√≠ficas que o comando deve ser executado. No comando `ls` por exemplo, podemos informar o par√¢metro `--colors` para termos uma lista formatada por cor, diferenciando pastas, arquivos e atalhos.

![Comando cd e ls --color](/assets/images/posts/ls-color.png)

Isso pode parecer lento, mas √© exatamente o contr√°rio. Em grande parte das vezes, o ambiente de linha de comando ser√° muito mais r√°pido que com mouse (e j√° descorrerei mais sobre isso).

<Slider>  
  <Card 
    title="ls"
    description="Lista todos os items presentes no diret√≥rio atual"
    examples={[
      {
        description: "Lista todos os arquivos e diret√≥rios do diret√≥rio atual",
        command: "ls"
      },
      {
        description: "Lista todos os conte√∫dos, incluindo arquivos secretos (a) e em lista vertical (l) " ,
        command: "ls -la"
      }
    ]}
  >
  gabo@book:&#126;$ ls
  Applications  Documents  logseq  packages  projects  Sync       tmenus
  Desktop       Downloads  Music   Pictures  Public    Templates  Videos
  gabo@book:&#126;$
  </Card>

  <Card
    title="cd"
    description="(Change Directory) Use para navegar entre diret√≥rios"
    examples={[
      {
        description: "Ir para o diret√≥rio 'user'",
        command: 'cd /home/user',
      },
      {
        description: 'Ir para o diret√≥rio pai',
        command: 'cd ..',
      },
    ]}
    >
      gabo@book:&#126;$ cd study
      gabo@book:&#126;/study$

  </Card>

  <Card
    title="cat"
    description="Concatena e mostra conte√∫dos de arquivos de texto"
    examples={[
      {
        description: 'Apresenta o arquivo.txt em tela',
        command: 'cat arquivo.txt',
      },
      {
        description: 'Concatena dois arquivos e gera um novo como resultado',
        command: 'cat arq1 arq2 > novo_arq',
      },
    ]}
  >
    gabo@book:&#126;$ cat free.md
    The four essential freedoms

    A program is free software if the program's users have the four essential freedoms: [1]

    The freedom to run the program as you wish, for any purpose (freedom 0).
    The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.
    The freedom to redistribute copies so you can help others (freedom 2).
    The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this.

  </Card>

  <Card 
    title="find"
    description="Encontra conte√∫dos dentro de um dado diret√≥rio, recursivamente"
    examples={[
      {
        description: 'Encontrar arquivos .txt, no diret√≥rio downloads',
        command: "find downloads -name '*.txt'"
      },
      {
        description: "Procurar apenas por diret√≥rios no diret√≥rio atual",
        command: "find . -type d"
      }
    ]}
  >
  gabo@book:&#126;/project$ find . -name "*.png"
  ./public/assets/images/posts/ls.png
  ./public/assets/images/posts/curl-h.png
  ./public/assets/images/posts/mkdir-h.png
  ./public/assets/images/posts/terminals.png
  ./node_modules/@astrojs/webapi/node_modules/undici/docs/assets/lifecycle-diagram.png
  ./node_modules/undici/docs/assets/lifecycle-diagram.png
  ./src/assets/images/terminal.png
  ./src/assets/images/dotfiles.png
  ./src/assets/images/video.png
  ./src/assets/images/hero.png
  ./src/assets/images/default.png
  ./src/assets/images/profile_picture.png
  ./src/assets/images/projects/wildberries.png
  ./src/assets/images/projects/symbols.png
  ./src/assets/images/cli-dark.png
  gabo@book:&#126;/project$
  </Card>
  
  <Card 
    title="pwd"
    description="Retorna o nome do diret√≥rio atual"
    examples={[
      {
        description: 'Apresenta nome do diret√≥rio atual',
        command: "pwd"
      },
    ]}
  >
  gabo@book:&#126;/project$ pwd
  /home/gabo/projects
  gabo@book:&#126;/project$
  </Card>
  
  <Card 
    title="rm"
    description="Utilizado para remover arquivos"
    examples={[
      {
        description: 'Remove o arquivo favicon.ico, mas pede confirma√ß√£o da a√ß√£o antes',
        command: "rm -i favicon.icon"
      },
      {
        description: "Remove a pasta Downloads, e todos os seus arquvivos e pastas dentro (-r de recursivo)",
        command: "rm -r Downloads"
      }
    ]}
  >
  gabo@book:&#126;/project$ rm -rf personal-blog
  gabo@book:&#126;/project$ 
  </Card>
</Slider>

Esse estilo por "chat" de intera√ß√£o √© chamado de `CLI` (do ingl√™s, `interface de linha de comando`).

E por interagir por texto, n√£o quer dizer que tudo se resume √† essa troca de mensagem. Aplica√ß√µes para o terminal tamb√©m podem ter interfaces visuais pr√≥prias bem ricas.

Como por exemplo o `vim` e `nvim` (editores de texto), `htop` e `bpytop` (gerenciadores de tarefas), players de m√∫sica como `moc`, entre outros v√°rios para email, calend√°rio e at√© navegar pela web. Se usa muito o termo TUI (Text User Interface) para descrever esse tipo de programa.

![Aplica√ß√µes de terminal](/assets/images/posts/tui.png)

[O projeto awesome-cli-apps](https://github.com/agarrharr/awesome-cli-apps) tem uma lista enorme de programas interessantes para o terminal.

E n√£o, eles n√£o podem competir em tudo com aplica√ß√µes GUI (Graphical User Interface). Quando voc√™ entende as utilidades do terminal, voc√™ tira o melhor proveito dele.

## Como eu sei o que um comando faz?

√â bom lembrar que ningu√©m come√ßa sabendo, e sempre haver√° novos comandos que voc√™ pode aprender dependendo da sua necessidade. Afinal s√£o apenas programas novos. √â normal voc√™ precisar entender como usar um comando, e um comando decente ter√° no m√≠nimo um desses dois recursos para voc√™ aprender como us√°-lo:

### --help e/ou -h

N√£o sabe como usar um certo comando? Tente cham√°-lo com um -h ou --help logo depois. Nem sempre -h funcionar√° para ajuda, pois o comando j√° o usa pra outro intuito. Na d√∫vida, tente os dois.

<Slider>
  <div>
    ![Chamada do comando curl -h](/assets/images/posts/curl-h.png)
    <div class="bg-dark-purple">
      Ao chamar curl -h, √© apresentado:
       - como a estrutura do comando deve ser (curl [op√ß√µes] url)
       - quais s√£o as op√ß√µes dispon√≠veis para utilizar com o comando (-)
    </div>

  </div>
  <div>
    ![Chamada do comando mkdir -h](/assets/images/posts/mkdir-h.png)
    Em casos como para o mkdir, √© necess√°rio utilizar --help
  </div>
</Slider>

Voc√™ pode esperar no m√≠nimo **instru√ß√µes de uso** com esses argumentos. Caso queira compreender mais a fun√ß√£o/intuito do comando, a pr√≥xima op√ß√£o far√° mais sentido.

### P√°gina man

Se voc√™ precisa entender **para que serve** um certo comando, as **p√°ginas man** servir√£o como um **man**ual. P√°ginas man s√£o p√°ginas em texto que decrevem tudo o que √© poss√≠vel sobre um determinado comando. Eles s√£o arquivos que voc√™ chama digitando `man nome-do-comando`. No exemplo a baixo, o comando chama o manual do comando `find`.

<Card
  title="man"
  description="Um apresentador dos manuais do sistema"
  examples={[
    {
      description: 'Apresenta o manual do comando cat',
      command: 'man cat',
    },
    {
      description: 'Apresenta manual do comando, na se√ß√£o 7',
      command: 'man cat.7',
    },
  ]}
>
FIND(1)                     General Commands Manual                    FIND(1)

NAME
find - search for files in a directory hierarchy

SYNOPSIS
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [ex‚Äê
pression]

DESCRIPTION
This manual page documents the GNU version of find. GNU find searches
the directory tree rooted at each given starting-point by evaluating
the given expression from left to right, according to the rules of
precedence (see section OPERATORS), until the outcome is known (the
left hand side is false for and operations, true for or), at which
point find moves on to the next file name. If no starting-point is
specified, `.' is assumed.

       If you are using find in an environment  where  security  is  important
       (for  example  if  you  are  using  it  to  search directories that are
       writable by other users), you should read the `Security Considerations'
       chapter  of  the findutils documentation, which is called Finding Files

Manual page find(1) line 1 (press h for help or q to quit)

</Card>

## Por que usar o terminal

Recaptulando, h√° duas formas principais de se interagir com o computador:

- **Por aplica√ß√µes gr√°ficas (GUI)**, que desenham e processam livremente os pixels na tela, esperando que voc√™ navegue pela tela com o mouse;
- **Por aplica√ß√µes de terminal (CLI, TUI)**, apresentando informa√ß√µes basedas em texto;

Muitos dos programas que se usa por interface gr√°fica tamb√©m tem para o terminal.

![Gerenciadores de arquivos - pcmanfm e nnn](/assets/images/posts/explorer.png)
_Gerenciadores de arquivos - pcmanfm e nnn_

![Editores de texto - vscodium e nvim](/assets/images/posts/editor.png)
_Editores de texto - vscodium e nvim_

N√£o se pode concluir uma forma como _a_ melhor, mas h√° muitas situa√ß√µes onde de fato o terminal se destaca:

### ‚ö° Velocidade no limite do seu alcan√ße

Como j√° dito, ao se usar o terminal, voc√™ se ver√° navegando muito pelos diret√≥rios do seu sistema. E, sem muito tempo de uso, voc√™ j√° pode estar navegando super r√°pido. Me acompanha: se voc√™ for uma pessoa que j√° se d√° bem digitando no computador, imagina usar essa velocidade pra navegar por ele. Essa velocidade n√£o precisa ficar s√≥ na navega√ß√£o de arquivos e n√£o se resume √† digita√ß√£o de palavras. Ter macros e comandos no teclado para controlar o programa √© comum. **Para uma aplica√ß√£o com bom suporte ao teclado, toda intera√ß√£o pode ser feita na velocidade que sua digita√ß√£o alcan√ßar**, e isso lhe permite ir melhorando com a pr√°tica.

Os benef√≠cios s√£o claros tamb√©m pra quem n√£o digita r√°pido. Entre **navegar mais de uma tela**/menu ou digitar/**copiar uma √∫nica frase** no seu terminal, voc√™ pode ganhar tempo com a segunda op√ß√£o. **Voc√™ n√£o est√° ref√©m do que a tela lhe mostra para clicar.** Como exemplo, pense o caminho que voc√™ faz para instalar um programa novo: voc√™ pesquisa o nome dele na internet, acha o site correto, segue os passos para baixar algum arquivo para a√≠ ent√£o clic√°-lo para instalar. Um jeito mais r√°pido √© caso j√° se procure numa loja de aplicativos do sistema, mas mesmo assim, como isso se compara com apenas digitar no terminal "apt install _nome-do-programa_" ou semelhante?

### üéØ Precis√£o descritiva

Uma coisa que a linha de comando permite de forma natural √© a chance de lidarmos com o computador de forma muito espec√≠fica. Sabe quando voc√™ pede uma pizza num aplicativo, **clicando** em cada sabor, sem muito problema? Se voc√™ quer pedir para tirar algum ingrediente espec√≠fico de algum sabor, uma √°rea para escrever um coment√°rio resolveria, n√©?

Voc√™ nunca ter√° **todas** as op√ß√µes poss√≠veis de pedido numa tela, por isso h√° dispon√≠vel o que √© mais comum. Mas para qualquer outra op√ß√£o mais espec√≠fica, h√° uma forma mais aberta para voc√™ definir: escrevendo.

√â dessa forma que interface gr√°fica e linha de comando se completam. Elas se diferenciam pela **densidade de informa√ß√µes** que uma situa√ß√£o demanda. O quanto √© poss√≠vel dar de informa√ß√µes ao dar um comando:

- Em **GUI** recebemos informa√ß√µes mais bem apresentadas, mas o _input_ do usu√°rio √© mais simples e menos denso, como um prato _a la carte_ no card√°pio.
- Em **CLI** voc√™ possui uma gama de op√ß√µes dispon√≠veis que podem ser declaradas todas de uma vez, do seu jeito. Como seu prato do _buffet_, que tem muito mais batata frita que deveria.

### Adicionar exemplo

### üîó Integra√ß√£o de f√°brica

Lembre-se que nessa conversa com o computador, as palavras s√£o literalmente programas ou dados para programas. Um comando no terminal pode ser s√≥ uma **palavra**, mas tamb√©m uma **frase**. Com o charactere `|`, tamb√©m conhecdo como pipe, a informa√ß√£o que um comando retorna pode ser usada para o pr√≥ximo comando, e assim por diante. Montar comandos obedecendo essa sintaxe simples faz com que naturalmente integra√ß√µes sejam feitas.

No exemplo abaixo, a lista de itens que o ls retornar√° ser√° filtrada pelo grep, resultando apenas as linhas que incluem .png, ou seja, os arquivos .png listados.

```bash
$ ls -l Downloads | grep .png
```

![Funcionamento do pipe de um comando ao outro](/assets/images/posts/pipe.png)

A natureza baseada em texto dos programas de terminal permitem uma consist√™ncia na forma que se mexe no computador, criando uma experi√™ncia unificada. At√© para programas de interface gr√°fica, √© possivel chamar comandos que fazem o mesmo que se faz clicando, e voc√™ acaba estendendo os programas do dia a dia para a sua necessidade. E por sinal, o que for de necessidade di√°ria, voc·∫Ω pode automatizar!

### ü§ñ Automa√ß√£o

Para toda linha de comando que voc√™ escreve, √© poss√≠vel execut√°-las de uma vez s√≥. Voc√™ faz isso por meio de scripts. Scripts s√£o arquivos onde voc√™ escreve todos os comandos que queria e a l√≥gica para execu√ß√£o deles. Scripts podem ser muito mais que uma s√©rie de comandos. Na verdade, o bash √©, al√©m de um interpretador de comandos, uma linguagem de programa√ß√£o!

Se aprofundar em bash √© um t√≥pico a parte, mas com muito pouco √© poss√≠vel facilitar a vida com ele. No exemplo abaixo, eu vou criar um comando chamado journal, onde eu abro o meu caderno de anota√ß√µes di√°rio. Caso eu n√£o tenha criado um novo arquivo para o dia de hoje, eu crio ele e abro no meu editor de texto. Caso o arquivo j√° exista, eu apenas o abro no editor.

```bash
#!/bin/bash

# Defino o nome do meu arquivo do dia.
# Eu uso o comando date para pegar consultar o dia de hoje.
name=day-$(date +%Y-%m-%d)

# Defino o caminho completo do arquivo.
# Eu uso a vari√°vel global $HOME para declarar o caminho do meu home.
file="$HOME/$name.txt"

# Caso o arquivo nesse caminho n√£o exista, eu o crio.
[ ! -f "$file" ] && touch $file

# Abro o arquivo no editor vim
vim $file

```

## N√£o tenha medo do terminal (e dicas pra facilitar a vida)

Em conclus√£o

- N√£o √© dificil, √© diferente
- TUI n√£o precisa ser feio
- N√£o tem oq temer pois ele faz apenas o que vc manda, e n√£o √© t√£o facil fazer algo que fa√ßa mal
- novos comandos, como girias, que lhe permitem fazer coisas diferentes

terminal burro: http://www.linfo.org/dumb_terminal.htm
